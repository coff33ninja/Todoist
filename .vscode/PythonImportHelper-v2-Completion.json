[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "datasets",
        "description": "datasets",
        "isExtraImport": true,
        "detail": "datasets",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "datasets",
        "description": "datasets",
        "isExtraImport": true,
        "detail": "datasets",
        "documentation": {}
    },
    {
        "label": "DistilBertTokenizerFast",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "DistilBertForSequenceClassification",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "TrainingArguments",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModelForSequenceClassification",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "TrainingArguments",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "softmax",
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "isExtraImport": true,
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "pytesseract",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytesseract",
        "description": "pytesseract",
        "detail": "pytesseract",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_from_directory",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "InventoryManager",
        "importPath": "core.inventory_manager",
        "description": "core.inventory_manager",
        "isExtraImport": true,
        "detail": "core.inventory_manager",
        "documentation": {}
    },
    {
        "label": "ReceiptProcessor",
        "importPath": "ai.receipt_processor",
        "description": "ai.receipt_processor",
        "isExtraImport": true,
        "detail": "ai.receipt_processor",
        "documentation": {}
    },
    {
        "label": "TaskManager",
        "importPath": "core.task_manager",
        "description": "core.task_manager",
        "isExtraImport": true,
        "detail": "core.task_manager",
        "documentation": {}
    },
    {
        "label": "BudgetTracker",
        "importPath": "utils.budget_tracker",
        "description": "utils.budget_tracker",
        "isExtraImport": true,
        "detail": "utils.budget_tracker",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "NLUProcessor",
        "importPath": "ai.nlu_processor",
        "description": "ai.nlu_processor",
        "isExtraImport": true,
        "detail": "ai.nlu_processor",
        "documentation": {}
    },
    {
        "label": "NLUProcessor",
        "importPath": "ai.nlu_processor",
        "description": "ai.nlu_processor",
        "isExtraImport": true,
        "detail": "ai.nlu_processor",
        "documentation": {}
    },
    {
        "label": "NLUProcessor",
        "importPath": "ai.nlu_processor",
        "description": "ai.nlu_processor",
        "isExtraImport": true,
        "detail": "ai.nlu_processor",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "FlaskClient",
        "importPath": "flask.testing",
        "description": "flask.testing",
        "isExtraImport": true,
        "detail": "flask.testing",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "core.main",
        "description": "core.main",
        "isExtraImport": true,
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "NLUModel",
        "kind": 6,
        "importPath": "ai.nlu_model",
        "description": "ai.nlu_model",
        "peekOfCode": "class NLUModel:\n    def __init__(\n        self,\n        model_name=\"distilbert-base-uncased\",\n        model_save_path=\"ai_models/nlu_model\",\n    ):\n        self.model_name = model_name\n        self.model_save_path = model_save_path\n        self.tokenizer = DistilBertTokenizerFast.from_pretrained(model_name)\n        self.model = DistilBertForSequenceClassification.from_pretrained(model_name)",
        "detail": "ai.nlu_model",
        "documentation": {}
    },
    {
        "label": "NLUProcessor",
        "kind": 6,
        "importPath": "ai.nlu_processor",
        "description": "ai.nlu_processor",
        "peekOfCode": "class NLUProcessor:\n    def __init__(self, model_path='ai_models/nlu_model.pkl'):\n        # Initialize patterns for basic matching\n        self.patterns = {\n            'search': [\n                r'show\\s+(?:me\\s+)?(?:all\\s+)?(?:the\\s+)?'\n                r'(?:items?|products?|things?)(?:\\s+in\\s+(.+))?',\n                r'what\\s+(?:items?|products?|things?)'\n                r'(?:\\s+do\\s+I\\s+have)?(?:\\s+in\\s+(.+))?',\n                r'list\\s+(?:all\\s+)?(?:items?|products?|things?)'",
        "detail": "ai.nlu_processor",
        "documentation": {}
    },
    {
        "label": "ReceiptProcessor",
        "kind": 6,
        "importPath": "ai.ocr_processor",
        "description": "ai.ocr_processor",
        "peekOfCode": "class ReceiptProcessor:\n    def __init__(self):\n        # Configure Tesseract path if needed\n        # pytesseract.pytesseract.tesseract_cmd = r'C:\\Program Files\\Tesseract-OCR\\tesseract.exe'\n        pass\n    def preprocess_image(self, image_path):\n        \"\"\"Preprocess the receipt image for better OCR results\"\"\"\n        try:\n            # Load image\n            img = cv2.imread(image_path)",
        "detail": "ai.ocr_processor",
        "documentation": {}
    },
    {
        "label": "ReceiptProcessor",
        "kind": 6,
        "importPath": "ai.receipt_processor",
        "description": "ai.receipt_processor",
        "peekOfCode": "class ReceiptProcessor:\n    def __init__(self, tesseract_path=None):\n        if tesseract_path:\n            pytesseract.pytesseract.tesseract_cmd = tesseract_path\n    def preprocess_image(self, image_path):\n        \"\"\"Preprocess image for better OCR results\"\"\"\n        img = cv2.imread(image_path)\n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        # Apply thresholding\n        _, processed = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)",
        "detail": "ai.receipt_processor",
        "documentation": {}
    },
    {
        "label": "InventoryManager",
        "kind": 6,
        "importPath": "core.inventory_manager",
        "description": "core.inventory_manager",
        "peekOfCode": "class InventoryManager:\n    _instance = None\n    _lock = threading.Lock()\n    def __init__(self, db_path='inventory.db'):\n        self.db_path = db_path\n        self._local = threading.local()\n    def get_connection(self):\n        \"\"\"Get a thread-local database connection\"\"\"\n        if not hasattr(self._local, 'conn'):\n            self._local.conn = sqlite3.connect(self.db_path)",
        "detail": "core.inventory_manager",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "def get_db():\n    \"\"\"Get database connection with row factory\"\"\"\n    if not hasattr(db_local, \"conn\"):\n        db_local.conn = sqlite3.connect(DATABASE)\n        db_local.conn.row_factory = sqlite3.Row\n    return db_local.conn\ndef close_db():\n    \"\"\"Close the database connection\"\"\"\n    if hasattr(db_local, \"conn\"):\n        try:",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "close_db",
        "kind": 2,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "def close_db():\n    \"\"\"Close the database connection\"\"\"\n    if hasattr(db_local, \"conn\"):\n        try:\n            db_local.conn.close()\n        except Exception:\n            pass\n        finally:\n            if hasattr(db_local, \"conn\"):\n                del db_local.conn",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "teardown_db",
        "kind": 2,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "def teardown_db(_):\n    close_db()\ndef init_db():\n    # Close any existing connections\n    close_db()\n    # Initialize components with thread-local storage after database reset\n    global inventory, receipt_processor, task_manager, budget_tracker\n    try:\n        # Initialize the inventory manager first, which will create the tables\n        inventory = InventoryManager(DATABASE)",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "init_db",
        "kind": 2,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "def init_db():\n    # Close any existing connections\n    close_db()\n    # Initialize components with thread-local storage after database reset\n    global inventory, receipt_processor, task_manager, budget_tracker\n    try:\n        # Initialize the inventory manager first, which will create the tables\n        inventory = InventoryManager(DATABASE)\n        # Initialize other components\n        receipt_processor = ReceiptProcessor()",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "add_item",
        "kind": 2,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "def add_item():\n    data = request.get_json()\n    required_fields = [\"name\"]\n    if not all(field in data for field in required_fields):\n        return jsonify({\"error\": \"Missing required fields\"}), 400\n    try:\n        item_id = inventory.add_item(\n            name=data[\"name\"],\n            description=data.get(\"description\"),\n            quantity=data.get(\"quantity\", 1),",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "add_repair",
        "kind": 2,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "def add_repair():\n    data = request.get_json()\n    required_fields = [\"item_id\", \"description\"]\n    if not all(field in data for field in required_fields):\n        return jsonify({\"error\": \"Missing required fields\"}), 400\n    try:\n        # Add the repair record\n        repair_id = task_manager.add_repair(\n            item_id=data[\"item_id\"],\n            description=data[\"description\"],",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "upload_receipt",
        "kind": 2,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "def upload_receipt():\n    if \"file\" not in request.files:\n        return jsonify({\"error\": \"No file part\"}), 400\n    file = request.files[\"file\"]\n    if file.filename == \"\":\n        return jsonify({\"error\": \"No selected file\"}), 400\n    try:\n        # Save the file\n        file_path = os.path.join(str(UPLOAD_FOLDER), str(file.filename))\n        file.save(file_path)",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "get_receipt",
        "kind": 2,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "def get_receipt(filename):\n    return send_from_directory(UPLOAD_FOLDER, filename)\n@app.route(\"/api/query\", methods=[\"POST\"])\ndef handle_query():\n    data = request.get_json()\n    query_text = data.get(\"query\", \"\")\n    if not query_text:\n        return jsonify({\"error\": \"No query provided\"}), 400\n    try:\n        # Import NLUProcessor only when needed to avoid circular imports",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "handle_query",
        "kind": 2,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "def handle_query():\n    data = request.get_json()\n    query_text = data.get(\"query\", \"\")\n    if not query_text:\n        return jsonify({\"error\": \"No query provided\"}), 400\n    try:\n        # Import NLUProcessor only when needed to avoid circular imports\n        from ai.nlu_processor import NLUProcessor\n        nlu_processor = NLUProcessor()\n        response = nlu_processor.process_natural_language_query(",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "app = Flask(__name__)\nCORS(app)\n# Configure upload folder\nUPLOAD_FOLDER = \"uploads\"\nif not os.path.exists(UPLOAD_FOLDER):\n    os.makedirs(UPLOAD_FOLDER)\n# Database setup\nDATABASE = \"inventory.db\"\ndb_local = threading.local()\ndef get_db():",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "UPLOAD_FOLDER",
        "kind": 5,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "UPLOAD_FOLDER = \"uploads\"\nif not os.path.exists(UPLOAD_FOLDER):\n    os.makedirs(UPLOAD_FOLDER)\n# Database setup\nDATABASE = \"inventory.db\"\ndb_local = threading.local()\ndef get_db():\n    \"\"\"Get database connection with row factory\"\"\"\n    if not hasattr(db_local, \"conn\"):\n        db_local.conn = sqlite3.connect(DATABASE)",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "DATABASE",
        "kind": 5,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "DATABASE = \"inventory.db\"\ndb_local = threading.local()\ndef get_db():\n    \"\"\"Get database connection with row factory\"\"\"\n    if not hasattr(db_local, \"conn\"):\n        db_local.conn = sqlite3.connect(DATABASE)\n        db_local.conn.row_factory = sqlite3.Row\n    return db_local.conn\ndef close_db():\n    \"\"\"Close the database connection\"\"\"",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "db_local",
        "kind": 5,
        "importPath": "core.main",
        "description": "core.main",
        "peekOfCode": "db_local = threading.local()\ndef get_db():\n    \"\"\"Get database connection with row factory\"\"\"\n    if not hasattr(db_local, \"conn\"):\n        db_local.conn = sqlite3.connect(DATABASE)\n        db_local.conn.row_factory = sqlite3.Row\n    return db_local.conn\ndef close_db():\n    \"\"\"Close the database connection\"\"\"\n    if hasattr(db_local, \"conn\"):",
        "detail": "core.main",
        "documentation": {}
    },
    {
        "label": "TaskManager",
        "kind": 6,
        "importPath": "core.task_manager",
        "description": "core.task_manager",
        "peekOfCode": "class TaskManager:\n    def __init__(self, db_path='inventory.db'):\n        self.db_path = db_path\n        self.conn = sqlite3.connect(db_path)\n        self.create_tables()\n    def create_tables(self):\n        cursor = self.conn.cursor()\n        # Table for repair tasks\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS repairs (",
        "detail": "core.task_manager",
        "documentation": {}
    },
    {
        "label": "install_dependencies",
        "kind": 2,
        "importPath": "scripts.install_deps",
        "description": "scripts.install_deps",
        "peekOfCode": "def install_dependencies():\n    \"\"\"Install or update project dependencies\"\"\"\n    try:\n        # Get the project root directory (where requirements.txt is located)\n        project_root = Path(__file__).parent.parent\n        requirements_file = project_root / \"requirements.txt\"\n        if not requirements_file.exists():\n            print(\"Error: requirements.txt not found!\")\n            return False\n        print(\"Uninstalling potentially conflicting packages...\")",
        "detail": "scripts.install_deps",
        "documentation": {}
    },
    {
        "label": "TestRunner",
        "kind": 6,
        "importPath": "scripts.run_tests",
        "description": "scripts.run_tests",
        "peekOfCode": "class TestRunner:\n    def __init__(self):\n        self.project_root = Path(__file__).parent.parent\n        self.test_dir = self.project_root / \"tests\"\n        self.start_time = None\n        self.end_time = None\n    def print_header(self, message):\n        \"\"\"Print a formatted header\"\"\"\n        print(\"\\n\" + \"=\" * 80)\n        print(f\" {message} \".center(80, \"=\"))",
        "detail": "scripts.run_tests",
        "documentation": {}
    },
    {
        "label": "write_lint_errors",
        "kind": 2,
        "importPath": "scripts.run_tests",
        "description": "scripts.run_tests",
        "peekOfCode": "def write_lint_errors(errors, output_file=\"lint_errors.json\"):\n    \"\"\"Write linting errors to a JSON file\"\"\"\n    try:\n        with open(output_file, \"w\") as f:\n            json.dump(errors, f, indent=2)\n        print(f\"Lint errors written to {output_file}\")\n    except Exception as e:\n        print(f\"Error writing lint errors: {e}\")\ndef main():\n    parser = argparse.ArgumentParser(description=\"Run project tests with various options\")",
        "detail": "scripts.run_tests",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.run_tests",
        "description": "scripts.run_tests",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"Run project tests with various options\")\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\", \n                        help=\"Enable verbose output\")\n    parser.add_argument(\"-c\", \"--coverage\", action=\"store_true\",\n                        help=\"Run tests with coverage report\")\n    parser.add_argument(\"-f\", \"--test-file\", type=str,\n                        help=\"Run specific test file (e.g., test_nlu_processor.py)\")\n    parser.add_argument(\"-t\", \"--test-function\", type=str,\n                        help=\"Run specific test function (e.g., test_inventory_query)\")",
        "detail": "scripts.run_tests",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.train_nlu",
        "description": "scripts.train_nlu",
        "peekOfCode": "def main():\n    # Sample training data\n    X = [\n        \"show me all items in the kitchen\",\n        \"how many items do I have in the garage\",\n        \"what is the total value of my inventory\",\n        \"list items that cost more than 50 dollars\",\n        \"count all products in storage\",\n        \"what items are in the living room\",\n        \"how much are my things worth\",",
        "detail": "scripts.train_nlu",
        "documentation": {}
    },
    {
        "label": "test_app",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def test_app():\n    \"\"\"Create a test Flask application\"\"\"\n    app.config['TESTING'] = True\n    return app\n@pytest.fixture\ndef client(test_app) -> FlaskClient:\n    \"\"\"Create a test client\"\"\"\n    return test_app.test_client()\n@pytest.fixture\ndef test_db():",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def client(test_app) -> FlaskClient:\n    \"\"\"Create a test client\"\"\"\n    return test_app.test_client()\n@pytest.fixture\ndef test_db():\n    \"\"\"Create a test database connection\"\"\"\n    # Use an in-memory database for testing\n    conn = sqlite3.connect(':memory:')\n    # Set up the row factory to return dictionaries\n    def dict_factory(cursor, row):",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "test_db",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def test_db():\n    \"\"\"Create a test database connection\"\"\"\n    # Use an in-memory database for testing\n    conn = sqlite3.connect(':memory:')\n    # Set up the row factory to return dictionaries\n    def dict_factory(cursor, row):\n        d = {}\n        for idx, col in enumerate(cursor.description):\n            d[col[0]] = row[idx]\n        return d",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "sample_data",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def sample_data(test_db):\n    \"\"\"Insert sample data into the test database\"\"\"\n    cursor = test_db.cursor()\n    # Insert sample items\n    cursor.execute(\"\"\"\n        INSERT INTO items (name, description, quantity, price)\n        VALUES\n            ('Test Item 1', 'Description 1', 1, 100.00),\n            ('Test Item 2', 'Description 2', 2, 200.00)\n    \"\"\")",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "test_query_endpoint_items",
        "kind": 2,
        "importPath": "tests.test_api_endpoints",
        "description": "tests.test_api_endpoints",
        "peekOfCode": "def test_query_endpoint_items(client, sample_data):\n    \"\"\"Test the /api/query endpoint with an items query\"\"\"\n    response = client.post('/api/query', \n                         json={'query': 'Show me all items'})\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert \"response\" in data\n    assert \"items in inventory\" in data[\"response\"]\ndef test_query_endpoint_repairs(client, sample_data):\n    \"\"\"Test the /api/query endpoint with a repairs query\"\"\"",
        "detail": "tests.test_api_endpoints",
        "documentation": {}
    },
    {
        "label": "test_query_endpoint_repairs",
        "kind": 2,
        "importPath": "tests.test_api_endpoints",
        "description": "tests.test_api_endpoints",
        "peekOfCode": "def test_query_endpoint_repairs(client, sample_data):\n    \"\"\"Test the /api/query endpoint with a repairs query\"\"\"\n    response = client.post('/api/query', \n                         json={'query': 'Show repair history'})\n    assert response.status_code == 200\n    data = json.loads(response.data)\n    assert \"response\" in data\n    assert \"repair records\" in data[\"response\"]\ndef test_query_endpoint_no_query(client):\n    \"\"\"Test the /api/query endpoint with missing query\"\"\"",
        "detail": "tests.test_api_endpoints",
        "documentation": {}
    },
    {
        "label": "test_query_endpoint_no_query",
        "kind": 2,
        "importPath": "tests.test_api_endpoints",
        "description": "tests.test_api_endpoints",
        "peekOfCode": "def test_query_endpoint_no_query(client):\n    \"\"\"Test the /api/query endpoint with missing query\"\"\"\n    response = client.post('/api/query', json={})\n    assert response.status_code == 400\n    data = json.loads(response.data)\n    assert \"error\" in data\ndef test_query_endpoint_empty_query(client):\n    \"\"\"Test the /api/query endpoint with empty query string\"\"\"\n    response = client.post('/api/query', \n                         json={'query': ''})",
        "detail": "tests.test_api_endpoints",
        "documentation": {}
    },
    {
        "label": "test_query_endpoint_empty_query",
        "kind": 2,
        "importPath": "tests.test_api_endpoints",
        "description": "tests.test_api_endpoints",
        "peekOfCode": "def test_query_endpoint_empty_query(client):\n    \"\"\"Test the /api/query endpoint with empty query string\"\"\"\n    response = client.post('/api/query', \n                         json={'query': ''})\n    assert response.status_code == 400\n    data = json.loads(response.data)\n    assert \"error\" in data",
        "detail": "tests.test_api_endpoints",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "tests.test_nlu",
        "description": "tests.test_nlu",
        "peekOfCode": "def get_db():\n    \"\"\"Mock database connection function\"\"\"\n    conn = sqlite3.connect('db/inventory.db')\n    conn.row_factory = sqlite3.Row\n    return conn\ndef test_queries():\n    nlu = NLUProcessor()\n    test_cases = [\n        \"show me all items in the kitchen\",\n        \"how many products do I have\",",
        "detail": "tests.test_nlu",
        "documentation": {}
    },
    {
        "label": "test_queries",
        "kind": 2,
        "importPath": "tests.test_nlu",
        "description": "tests.test_nlu",
        "peekOfCode": "def test_queries():\n    nlu = NLUProcessor()\n    test_cases = [\n        \"show me all items in the kitchen\",\n        \"how many products do I have\",\n        \"what is the total value of my inventory\",\n        \"list items that cost more than 100 dollars\",\n        \"count all things in storage\",\n        \"what items are in the living room\",\n        \"how much are my things worth\",",
        "detail": "tests.test_nlu",
        "documentation": {}
    },
    {
        "label": "test_intent_classification",
        "kind": 2,
        "importPath": "tests.test_nlu_processor",
        "description": "tests.test_nlu_processor",
        "peekOfCode": "def test_intent_classification():\n    \"\"\"Test the transformer model's intent classification\"\"\"\n    processor = NLUProcessor()\n    test_cases = [\n        (\"show me all items in the kitchen\", \"search\"),\n        (\"how many products do I have\", \"count\"),\n        (\"what is the total value of my inventory\", \"value\"),\n        (\"list items that cost more than 100 dollars\", \"price_range\"),\n        (\"unknown query that should fail\", \"unknown\")\n    ]",
        "detail": "tests.test_nlu_processor",
        "documentation": {}
    },
    {
        "label": "test_response_format",
        "kind": 2,
        "importPath": "tests.test_nlu_processor",
        "description": "tests.test_nlu_processor",
        "peekOfCode": "def test_response_format():\n    \"\"\"Test the response format for different intents\"\"\"\n    processor = NLUProcessor()\n    # Mock database function\n    def mock_db():\n        class MockCursor:\n            def execute(self, query, params):\n                pass\n            def fetchall(self):\n                return [{\"name\": \"Test Item\", \"price\": 10.0}]",
        "detail": "tests.test_nlu_processor",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "tests.test_nlu_processor",
        "description": "tests.test_nlu_processor",
        "peekOfCode": "def test_performance():\n    \"\"\"Test the performance of the NLU processor\"\"\"\n    processor = NLUProcessor()\n    # Warm up\n    for _ in range(5):\n        processor.process_natural_language_query(\"test query\", lambda: None)\n    # Measure performance\n    start_time = time.time()\n    for _ in range(100):\n        processor.process_natural_language_query(\"show me all items\", lambda: None)",
        "detail": "tests.test_nlu_processor",
        "documentation": {}
    },
    {
        "label": "test_error_handling",
        "kind": 2,
        "importPath": "tests.test_nlu_processor",
        "description": "tests.test_nlu_processor",
        "peekOfCode": "def test_error_handling():\n    \"\"\"Test error handling in the NLU processor\"\"\"\n    processor = NLUProcessor()\n    # Test database error\n    def failing_db():\n        raise Exception(\"Database connection failed\")\n    result = processor.process_natural_language_query(\"show me all items\", failing_db)\n    assert result.get(\"error\") == \"Database connection failed\"\n    # Test invalid query\n    result = processor.process_natural_language_query(\"invalid query\", lambda: None)",
        "detail": "tests.test_nlu_processor",
        "documentation": {}
    },
    {
        "label": "test_various_phrasings",
        "kind": 2,
        "importPath": "tests.test_nlu_processor",
        "description": "tests.test_nlu_processor",
        "peekOfCode": "def test_various_phrasings(query, expected_intent):\n    \"\"\"Test various phrasings for each intent\"\"\"\n    processor = NLUProcessor()\n    result = processor.process_natural_language_query(query, lambda: None)\n    assert result.get(\"intent\") == expected_intent, \\\n        f\"Expected {expected_intent} for query: {query}\"",
        "detail": "tests.test_nlu_processor",
        "documentation": {}
    },
    {
        "label": "BudgetTracker",
        "kind": 6,
        "importPath": "utils.budget_tracker",
        "description": "utils.budget_tracker",
        "peekOfCode": "class BudgetTracker:\n    def __init__(self, db_path='inventory.db'):\n        self.db_path = db_path\n        self.conn = sqlite3.connect(db_path)\n        self.create_tables()\n    def create_tables(self):\n        cursor = self.conn.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS budget (\n                id INTEGER PRIMARY KEY,",
        "detail": "utils.budget_tracker",
        "documentation": {}
    },
    {
        "label": "list_tables",
        "kind": 2,
        "importPath": "utils.inspect_db",
        "description": "utils.inspect_db",
        "peekOfCode": "def list_tables(db_path):\n    try:\n        conn = sqlite3.connect(db_path)\n        cursor = conn.cursor()\n        tables = cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\").fetchall()\n        print(\"Tables in database:\")\n        for table in tables:\n            print(f\"- {table[0]}\")\n            # Print columns for each table\n            columns = cursor.execute(f\"PRAGMA table_info({table[0]})\").fetchall()",
        "detail": "utils.inspect_db",
        "documentation": {}
    },
    {
        "label": "populate_test_data",
        "kind": 2,
        "importPath": "utils.populate_test_data",
        "description": "utils.populate_test_data",
        "peekOfCode": "def populate_test_data(db_path):\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    # Insert test items\n    cursor.executemany(\"\"\"\n        INSERT INTO items (name, description, quantity, purchase_date, price)\n        VALUES (?, ?, ?, ?, ?)\n    \"\"\", [\n        (\"Test Item 1\", \"First test item\", 5, \"2023-01-01\", 100.0),\n        (\"Test Item 2\", \"Second test item\", 3, \"2023-02-01\", 150.0)",
        "detail": "utils.populate_test_data",
        "documentation": {}
    },
    {
        "label": "start_application",
        "kind": 2,
        "importPath": "start",
        "description": "start",
        "peekOfCode": "def start_application():\n    \"\"\"Start the Flask application\"\"\"\n    print(\"Starting Todoist application...\")\n    # Set Python path before running the application\n    env = os.environ.copy()\n    env[\"PYTHONPATH\"] = os.path.abspath(os.path.dirname(__file__))\n    subprocess.run([\"python\", \"core/main.py\"], env=env)\ndef train_model():\n    \"\"\"Train the NLU model\"\"\"\n    print(\"Training NLU model...\")",
        "detail": "start",
        "documentation": {}
    },
    {
        "label": "train_model",
        "kind": 2,
        "importPath": "start",
        "description": "start",
        "peekOfCode": "def train_model():\n    \"\"\"Train the NLU model\"\"\"\n    print(\"Training NLU model...\")\n    subprocess.run([\"python\", \"scripts/train_nlu.py\"])\ndef run_tests():\n    \"\"\"Run all tests\"\"\"\n    print(\"Running tests...\")\n    subprocess.run([\"pytest\", \"tests/\"])\ndef add_data():\n    \"\"\"Add sample data to the database\"\"\"",
        "detail": "start",
        "documentation": {}
    },
    {
        "label": "run_tests",
        "kind": 2,
        "importPath": "start",
        "description": "start",
        "peekOfCode": "def run_tests():\n    \"\"\"Run all tests\"\"\"\n    print(\"Running tests...\")\n    subprocess.run([\"pytest\", \"tests/\"])\ndef add_data():\n    \"\"\"Add sample data to the database\"\"\"\n    print(\"Adding sample data...\")\n    subprocess.run([\"python\", \"utils/populate_test_data.py\"])\ndef main():\n    parser = argparse.ArgumentParser(description=\"Todoist Application Management\")",
        "detail": "start",
        "documentation": {}
    },
    {
        "label": "add_data",
        "kind": 2,
        "importPath": "start",
        "description": "start",
        "peekOfCode": "def add_data():\n    \"\"\"Add sample data to the database\"\"\"\n    print(\"Adding sample data...\")\n    subprocess.run([\"python\", \"utils/populate_test_data.py\"])\ndef main():\n    parser = argparse.ArgumentParser(description=\"Todoist Application Management\")\n    parser.add_argument(\"command\", choices=[\"start\", \"train\", \"test\", \"add-data\"],\n                       help=\"Command to execute: start, train, test, or add-data\")\n    args = parser.parse_args()\n    if args.command == \"start\":",
        "detail": "start",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "start",
        "description": "start",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"Todoist Application Management\")\n    parser.add_argument(\"command\", choices=[\"start\", \"train\", \"test\", \"add-data\"],\n                       help=\"Command to execute: start, train, test, or add-data\")\n    args = parser.parse_args()\n    if args.command == \"start\":\n        start_application()\n    elif args.command == \"train\":\n        train_model()\n    elif args.command == \"test\":",
        "detail": "start",
        "documentation": {}
    },
    {
        "label": "root_dir",
        "kind": 5,
        "importPath": "start",
        "description": "start",
        "peekOfCode": "root_dir = os.path.abspath(os.path.dirname(__file__))\nsys.path.insert(0, root_dir)\nimport subprocess\nimport sys\nimport os\ndef start_application():\n    \"\"\"Start the Flask application\"\"\"\n    print(\"Starting Todoist application...\")\n    # Set Python path before running the application\n    env = os.environ.copy()",
        "detail": "start",
        "documentation": {}
    }
]